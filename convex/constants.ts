export {
  AI_GENERATION_RETRY_DELAYS_MS,
  AI_MIN_ANSWER_LENGTH,
  AI_MIN_PROMPT_LENGTH,
  AI_PROMPT_EXAMPLE_COUNT,
  AI_REASONING_CALIBRATION_ALPHA_STEADY,
  AI_REASONING_CALIBRATION_ALPHA_WARMUP,
  AI_REASONING_CALIBRATION_DEFAULT_FACTOR,
  AI_REASONING_CALIBRATION_MAX_FACTOR,
  AI_REASONING_CALIBRATION_MIN_FACTOR,
  AI_REASONING_CALIBRATION_WARMUP_SAMPLE_COUNT,
  AI_REASONING_PROGRESS_FLUSH_INTERVAL_MS,
  ENGINE_RUNNER_MIN_ENABLED_MODELS,
  ENGINE_RUNNER_RETRY_ACTIVE_ROUND_PENDING_MS,
  ENGINE_RUNNER_RETRY_ACTIVE_ROUND_RECOVERED_MS,
  ENGINE_RUNNER_RETRY_BLOCKED_MS,
  ENGINE_RUNNER_RETRY_CREATE_ROUND_FAILED_MS,
  ENGINE_RUNNER_RETRY_PAUSED_MS,
  ENGINE_RUNNER_VOTE_MODEL_WAIT_MS,
  ENGINE_RUNNER_VOTE_WINDOW_POLL_MAX_MS,
  ENGINE_RUNNER_VOTE_WINDOW_POLL_MIN_MS,
  MODEL_ATTEMPTS,
  MODEL_CALL_TIMEOUT_MS,
  MODEL_PHASE_DEADLINE_MS,
  MODEL_RETRY_BACKOFF_MS,
  MODEL_TIMEOUT_GRACE_MS,
  OPENROUTER_BASE_URL,
  PLATFORM_VIEWER_POLL_INTERVAL_MS,
  POST_ROUND_DELAY_MS,
  ROUND_PURGE_BATCH_SIZE,
  RUNNER_LEASE_HEARTBEAT_MS,
  RUNNER_LEASE_MANUAL_RENEW_MS,
  RUNNER_LEASE_MS,
  SKIPPED_ROUND_DELAY_MS,
  TWITCH_API_BATCH_SIZE,
  VIEWER_REAPER_BATCH,
  VIEWER_REAPER_INTERVAL_MS,
  VIEWER_PRESENCE_REAPER_MAX_LIMIT,
  VIEWER_SESSION_TTL_MS,
  VIEWER_SHARD_COUNT,
  VIEWER_VOTE_WINDOW_ACTIVE_MS,
  VIEWER_VOTE_WINDOW_IDLE_MS,
  YOUTUBE_API_BATCH_SIZE,
} from "../config";
import { VIEWER_SHARD_COUNT } from "../config";

export const DEFAULT_SCORES: Record<string, number> = {};

export function hashToShard(input: string, shards = VIEWER_SHARD_COUNT): number {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    hash = (hash * 31 + input.charCodeAt(i)) | 0;
  }
  return Math.abs(hash) % shards;
}

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export function shuffle<T>(arr: T[]): T[] {
  const copy = [...arr];
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = copy[i];
    copy[i] = copy[j] as T;
    copy[j] = tmp as T;
  }
  return copy;
}
